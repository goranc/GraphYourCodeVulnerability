from re import findall

_version_operators = {
    '==': lambda x, y: x == y,
    '===': lambda x, y: x == y,
    '~=': lambda x, y: x == y or x > y,
    '!=': lambda x, y: x != y,
    '<': lambda x, y: x < y,
    '<=': lambda x, y: x == y or x < y,
    '>': lambda x, y: x > y,
    '>=': lambda x, y: x == y or x > y,
}


def resolve_version_expression(expr):
    if not expr or expr == "*":
        return []

    if isinstance(expr, str):
        # this may fail if expression is malformed, but at this point we are trusting the parser has done their job
        conditions = []
        for subexpr in expr.split(","):
            regex_match = findall(r"^([=~!<>]+) *([\d.A-Za-z]+)$", subexpr.strip())
            if not regex_match:
                print("Cannot parse", subexpr)
            conditions.append(regex_match[0])
        return conditions

    return expr  # trust that the input was properly formatted already


def version_match(target_version, conditions):
    for operator, version in conditions:
        if not _version_operators[operator](target_version, version):
            return False
    return True


def pack_version_expression(expr):
    if not expr:
        return "Unconstrained"

    if type(expr) == str:
        return expr.replace(" ", "")

    return ",".join(constraint if isinstance(constraint, str) else "".join(constraint) for constraint in expr)
