from json import JSONDecodeError, loads
from os.path import join
# noinspection PyCompatibility,PyProtectedMember
from pip._vendor.pkg_resources import RequirementParseError, parse_requirements as pip_parse_requirements
from sys import stderr
from toml import TomlDecodeError
from core.github.parsers.base import BaseParser
from core.github.parsers.python.pipfile import Pipfile
from core.versioning import resolve_version_expression


class PythonParser(BaseParser):
    def parse_file_for_dependencies(self, path, filename):
        yield from self.parse_requirements_file(path, filename)
        yield from self.parse_pipfile(path, filename)
        yield from self.parse_pipfile_lock(path, filename)

    def parse_requirements_file(self, path, filename):
        if (
            ("requirements" in filename and filename.endswith(".txt")) or
            path.split("/")[-1] == "requirements"
        ):
            yield from self.resolve_requirements(source=self.read_source(path, filename))

    def parse_pipfile(self, path, filename):
        if filename.lower() == "pipfile":
            try:
                lock_output = loads(Pipfile.load(join(path, filename)).lock())
                output = self.resolve_pipfile_lock_data(lock_output)
                yield from output
            except TomlDecodeError:
                pass  # not a valid Pipfile

    def parse_pipfile_lock(self, path, filename):
        if filename.lower() == "pipfile.lock":
            try:
                lock_output = loads(self.read_source(path, filename))
                output = self.resolve_pipfile_lock_data(lock_output)
                yield from output
            except JSONDecodeError:
                pass  # not a valid Pipfile lock file

    @staticmethod
    def resolve_pipfile_lock_data(lock_data):
        try:
            all_packages = {**lock_data["default"], **lock_data["develop"]}
            requirements = [{
                "type": "python.package", "name": package, "version": resolve_version_expression(
                    package_data if isinstance(package_data, str) else package_data.get("version", "*")
                )
            } for package, package_data in all_packages.items()]
            yield from requirements
        except KeyError:
            pass  # not a valid Pipfile lock file

    @staticmethod
    def resolve_requirements(source):
        try:
            requirements = []
            for requirement in pip_parse_requirements(source):
                requirements.append({
                    "type": "python.package", "name": requirement.key,
                    "version": resolve_version_expression(requirement.specs)
                })
                for extra in requirement.extras:
                    print("Did not resolve extras requirement", extra, "for", requirement.key, file=stderr)

            yield from requirements
        except (SyntaxError, RequirementParseError):
            pass  # pip install would have failed for this file, ignore any successfully parsed requirements
